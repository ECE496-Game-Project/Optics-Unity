var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { createContext, createElement, useContext, useMemo, useRef, useState } from 'react';
import { useSyncExternalStore } from 'use-sync-external-store/shim';
import { useSyncExternalStoreWithSelector } from 'use-sync-external-store/with-selector';
/**
 * Creates a context that updates its value when the values in the dictionary change
 * @param dictionary The dictionary to be watched. Must implement the EventDictionary type in the C#
 * @param displayName A displayName to identify this context easier in case of problems
 */
export function createDictionaryWatcher(dictionary, displayName) {
    var ctx = createContext(undefined);
    if (displayName)
        ctx.displayName = displayName;
    var createSubscriber = function (fields, isEqual) {
        var snapshot = (__assign({}, dictionary));
        return {
            subscribe: function (onStoreChange) {
                snapshot = (__assign({}, dictionary));
                var remove = dictionary === null || dictionary === void 0 ? void 0 : dictionary.AddListener(function () {
                    var prev = snapshot;
                    snapshot = (__assign({}, dictionary));
                    if (!fields)
                        onStoreChange();
                    else {
                        var it = fields.values();
                        for (var field = it.next().value; field; field = it.next().value) {
                            if (isEqual ? !isEqual(prev[field], snapshot[field]) : (prev[field] !== snapshot[field])) {
                                onStoreChange();
                                break;
                            }
                        }
                    }
                });
                if (!remove) {
                    if (displayName)
                        console.warn("".concat(displayName, " dictionary does not provide a change listener"));
                    else
                        console.warn('The dictionary does not provide a change listener');
                }
                return function () { return remove === null || remove === void 0 ? void 0 : remove(); };
            },
            getSnapshot: function () { return snapshot; },
        };
    };
    var defaultSubscriber = createSubscriber();
    var Provider = function GlobalsProvider(_a) {
        var children = _a.children;
        var value = useSyncExternalStore(defaultSubscriber.subscribe, defaultSubscriber.getSnapshot, defaultSubscriber.getSnapshot);
        return createElement(ctx.Provider, { value: value }, children);
    };
    function useDictionaryContext() {
        var context = useContext(ctx);
        if (context === undefined) {
            if (displayName)
                throw new Error("".concat(displayName, ".useContext must be used within a ").concat(displayName, ".Provider"));
            else
                throw new Error('useContext must be used within a provider');
        }
        return context;
    }
    function useValue(subscribeToAllFields, fieldEqual) {
        if (subscribeToAllFields === void 0) { subscribeToAllFields = false; }
        var fields = useMemo(function () { return new Set(); }, []);
        var fieldsRef = useRef(fields);
        var _a = useState(false), allFieldsSubscribed = _a[0], setAllFieldsSubscribed = _a[1];
        subscribeToAllFields || (subscribeToAllFields = allFieldsSubscribed);
        var subscriber = useMemo(function () { return subscribeToAllFields ? defaultSubscriber : createSubscriber(fieldsRef.current, fieldEqual); }, [subscribeToAllFields, fieldEqual]);
        var value = useSyncExternalStore(subscriber.subscribe, subscriber.getSnapshot, subscriber.getSnapshot);
        var proxy = new Proxy(value, {
            get: function (target, p, receiver) {
                fields.add(p);
                return value[p];
            },
            ownKeys: function (target) {
                if (!allFieldsSubscribed)
                    setAllFieldsSubscribed(true);
                return Reflect.ownKeys(target);
            },
            getOwnPropertyDescriptor: function (target, p) {
                fields.add(p);
                return __assign(__assign({}, Reflect.getOwnPropertyDescriptor(target, p)), { value: value[p] });
            },
        });
        return proxy;
    }
    function useSelector(selector, isEqual) {
        return useSyncExternalStoreWithSelector(defaultSubscriber.subscribe, defaultSubscriber.getSnapshot, defaultSubscriber.getSnapshot, selector, isEqual);
    }
    return { context: ctx, Provider: Provider, useValue: useValue, useContext: useDictionaryContext, useSelector: useSelector };
}
