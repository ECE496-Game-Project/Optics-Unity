import { createElement } from 'react';
import { ConcurrentRoot, LegacyRoot } from 'react-reconciler/constants';
import { version } from '../version';
import { DefaultView } from '../views/default-view';
import { ObjectsRepo } from './async/objects';
import { asyncReconciler } from './async/reconciler';
import { isDevelopment } from './constants';
import { syncReconciler } from './sync/reconciler';
var containerMap = new Map();
var renderCount = 0;
export function render(element, options) {
    if (options === void 0) { options = {}; }
    renderCount++;
    var hostContainer = (options === null || options === void 0 ? void 0 : options.hostContainer) || HostContainer;
    var cacheKey = hostContainer.InstanceId >= 0 ? hostContainer.InstanceId : hostContainer;
    var isAsync = !(options === null || options === void 0 ? void 0 : options.disableBatchRendering);
    var _a = containerMap.get(cacheKey) || {}, hostRoot = _a.hostRoot, asyncJobCallback = _a.asyncJobCallback;
    var findFiberByHostInstance = function () { return null; };
    if (!hostRoot) {
        var mode = (options === null || options === void 0 ? void 0 : options.mode) === 'legacy' ? LegacyRoot : ConcurrentRoot;
        if (isAsync) {
            var fiberCache_1 = isDevelopment ? new ObjectsRepo() : null;
            if (isDevelopment) {
                findFiberByHostInstance = function (instance) { return !instance ? null : fiberCache_1.getObject(instance.refId); };
            }
            var scheduled_1 = false;
            var commands_1 = [];
            commands_1.push = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (!scheduled_1) {
                    scheduled_1 = true;
                    Promise.resolve().then(function () {
                        asyncJobCallback();
                        scheduled_1 = false;
                    });
                }
                return Array.prototype.push.apply(commands_1, args);
            };
            var hostContainerInstance_1 = {
                type: 'native',
                commands: commands_1,
                component: hostContainer,
                context: hostContainer.Context,
                refId: hostContainer.RefId,
                fiberCache: fiberCache_1,
            };
            asyncJobCallback = function () {
                if (!commands_1.length)
                    return;
                var serialized = JSON.stringify(commands_1);
                commands_1.length = 0;
                hostContainerInstance_1.context.FlushCommands(serialized);
            };
            hostRoot = asyncReconciler.createContainer(hostContainerInstance_1, mode, null, false, undefined, '', function (error) { return console.error(error); }, null);
        }
        else {
            hostRoot = syncReconciler.createContainer(hostContainer, mode, null, false, undefined, '', function (error) { return console.error(error); }, null);
        }
        containerMap.set(cacheKey, { hostRoot: hostRoot, asyncJobCallback: asyncJobCallback });
    }
    var shouldWrapWithHelpers = !(options === null || options === void 0 ? void 0 : options.disableHelpers);
    if (shouldWrapWithHelpers) {
        var viewWrapperProps = {
            withHelpers: !(options === null || options === void 0 ? void 0 : options.disableHelpers),
            renderCount: renderCount,
        };
        element = createElement(DefaultView, viewWrapperProps, element);
    }
    var rc = isAsync ? asyncReconciler : syncReconciler;
    rc.updateContainer(element, hostRoot, null);
    rc.injectIntoDevTools({
        bundleType: isDevelopment ? 1 : 0,
        version: version,
        rendererPackageName: '@reactunity/renderer',
        rendererConfig: { isAsync: isAsync },
        findFiberByHostInstance: findFiberByHostInstance,
    });
    return rc;
}
/**
 * @deprecated Instead, import `render` directly from `@reactunity/renderer`
 */
export var Renderer = {
    render: function (element, options) {
        if (options === void 0) { options = {}; }
        return render(element, options);
    },
};
export var batchedUpdates = asyncReconciler.batchedUpdates;
export var flushSync = asyncReconciler.flushSync;
