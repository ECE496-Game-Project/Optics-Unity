var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import * as Reconciler from 'react-reconciler';
import { commonReconciler, getAllowedProps, stringizePoolKey, textTypes } from '../constants';
import { diffProperties } from '../diffing';
import { subContextRenderers } from '../subcontexts';
import { callbacksRepo, convertPropsToSerializable, objectsRepo } from './serializer';
var refId = 0;
var ctxMap = new Map();
var updateSubContext = function (instance) {
    var rend = subContextRenderers[instance.type];
    var root = instance === null || instance === void 0 ? void 0 : instance.root;
    var cur = instance;
    while (cur && !root) {
        root = cur.root;
        cur = cur.parent;
    }
    if (!root)
        return;
    var content = rend(root.subContext.node);
    if (instance.type === 'richtext') {
        // instance.hostContext.commands.push(['x', { r: root.refId, c: content }]);
        instance.hostContext.commands.push([6, root.refId, content]);
    }
    else if (instance.type === 'svg') {
        // instance.hostContext.commands.push(['u', { r: root.refId, t: 'svg', ...convertPropsToSerializable({ innerContent: content }) }]);
        instance.hostContext.commands.push([5, root.refId, 'svg', convertPropsToSerializable({ innerContent: content })]);
    }
};
var hostConfig = __assign(__assign({}, commonReconciler), { getRootHostContext: function (rootContainer) {
        var context = rootContainer.context;
        if (rootContainer.refId < 0) {
            refId++;
            rootContainer.context.SetRef(refId, rootContainer.component);
            rootContainer.refId = refId;
        }
        var existing = ctxMap.get(context);
        if (existing)
            return existing;
        var commands = rootContainer.commands;
        var flushCommands = function () {
            var serialized = JSON.stringify(commands);
            commands.length = 0;
            return serialized;
        };
        var fireEventByRef = function (ind, args) {
            return callbacksRepo.call(ind, args);
        };
        var getObjectRef = function (ind) {
            return objectsRepo.getObject(ind);
        };
        var getEventAsObjectRef = function (ind) {
            return callbacksRepo.getObject(ind);
        };
        context.BindCommands(flushCommands, fireEventByRef, getObjectRef, getEventAsObjectRef);
        var ctx = {
            context: context,
            commands: commands,
            refId: rootContainer.refId,
            type: 'native',
        };
        ctxMap.set(context, ctx);
        return ctx;
    }, getChildHostContext: function (parentCtx, type) {
        if (type === 'richtext' && parentCtx.type === 'native')
            return {
                type: 'richtext',
                hostContext: parentCtx,
                node: null,
                parent: null,
                root: null,
            };
        if (type === 'svg' && parentCtx.type === 'native')
            return {
                type: 'svg',
                hostContext: parentCtx,
                node: null,
                parent: null,
                root: null,
            };
        return parentCtx;
    }, getPublicInstance: function (instance) {
        if (instance.type === 'native')
            return instance.context.GetRef(instance.refId, instance.commands.length > 0);
        return null;
    }, supportsMutation: true, supportsHydration: false, supportsPersistence: false, supportsMicrotasks: true, supportsTestSelectors: false, isPrimaryRenderer: true, warnsIfNotActing: true, prepareForCommit: function () { return null; }, resetAfterCommit: function () { }, shouldDeprioritizeSubtree: function () { return false; }, clearContainer: function (container) {
        UnityBridge.clearContainer(container);
    }, createInstance: function (type, props, rootContainer, ctx, internalHandle) {
        var aProps = getAllowedProps(props, type);
        if (ctx.type === 'native') {
            refId++;
            // ctx.commands.push(['c', { t: type, r: refId, k: stringizePoolKey(props.pool), ...convertPropsToSerializable(aProps) }]);
            ctx.commands.push([0, refId, type, convertPropsToSerializable(aProps), stringizePoolKey(props.pool)]);
            if (rootContainer.fiberCache)
                rootContainer.fiberCache.setObject(refId, internalHandle);
            var res = __assign(__assign({}, ctx), { refId: refId });
            if (type === 'richtext') {
                res.subContext = {
                    type: 'richtext',
                    node: {
                        tag: '',
                        children: [],
                        attributes: aProps,
                    },
                    root: res,
                    hostContext: res,
                    parent: null,
                };
            }
            if (type === 'svg') {
                res.subContext = {
                    type: 'svg',
                    node: {
                        tag: '',
                        children: [],
                        attributes: aProps,
                    },
                    root: res,
                    hostContext: res,
                    parent: null,
                };
            }
            return res;
        }
        else if (ctx.type === 'richtext' || ctx.type === 'svg') {
            return __assign(__assign({}, ctx), { node: {
                    tag: type,
                    children: [],
                    attributes: aProps,
                } });
        }
    }, createTextInstance: function (text, rootContainer, ctx, internalHandle) {
        if (ctx.type === 'native') {
            refId++;
            // ctx.commands.push(['t', { r: refId, c: text }]);
            ctx.commands.push([1, refId, text]);
            if (rootContainer.fiberCache)
                rootContainer.fiberCache.setObject(refId, internalHandle);
            return __assign(__assign({}, ctx), { refId: refId });
        }
        else if (ctx.type === 'richtext' || ctx.type === 'svg') {
            return __assign(__assign({}, ctx), { node: { text: text } });
        }
    }, appendInitialChild: function (parent, child) {
        if (!child)
            return;
        if (parent.type === 'native' && parent.subContext)
            parent = parent.subContext;
        if (parent.type === 'native' && child.type === 'native') {
            // parent.commands.push(['a', { p: parent.refId, c: child.refId }]);
            parent.commands.push([2, parent.refId, child.refId]);
        }
        else if ((parent.type === 'richtext' && child.type === 'richtext') ||
            (parent.type === 'svg' && child.type === 'svg')) {
            if ('children' in parent.node)
                parent.node.children.push(child.node);
            child.root = parent.root;
            child.parent = parent;
            updateSubContext(child);
        }
    }, finalizeInitialChildren: function () { return false; }, commitMount: function (instance) { }, shouldSetTextContent: function (type) { return textTypes[type]; }, 
    // -------------------
    //     Mutation
    // -------------------
    prepareUpdate: function (instance, type, oldProps, newProps) {
        return diffProperties(oldProps, newProps);
    }, commitUpdate: function (instance, updatePayload, type) {
        var props = getAllowedProps(updatePayload, type);
        if (instance.type === 'native') {
            // instance.commands.push(['u', { r: instance.refId, t: type, ...convertPropsToSerializable(props) }]);
            instance.commands.push([5, instance.refId, type, convertPropsToSerializable(props)]);
        }
        else if (instance.type === 'richtext' || instance.type === 'svg') {
            if ('attributes' in instance.node)
                instance.node.attributes = __assign(__assign({}, instance.node.attributes), props);
            updateSubContext(instance);
        }
    }, commitTextUpdate: function (instance, oldText, newText) {
        if (instance.type === 'native') {
            // instance.commands.push(['x', { r: instance.refId, c: newText }]);
            instance.commands.push([6, instance.refId, newText]);
        }
        else if (instance.type === 'richtext' || instance.type === 'svg') {
            instance.node = { text: newText };
            updateSubContext(instance);
        }
    }, appendChild: function (parent, child) {
        if (!child)
            return;
        if (parent.type === 'native' && parent.subContext)
            parent = parent.subContext;
        if (parent.type === 'native' && child.type === 'native') {
            // child.commands.push(['a', { p: parent.refId, c: child.refId }]);
            child.commands.push([2, parent.refId, child.refId]);
        }
        else if ((parent.type === 'richtext' && child.type === 'richtext') ||
            (parent.type === 'svg' && child.type === 'svg')) {
            if ('children' in parent.node)
                parent.node.children.push(child.node);
            child.root = parent.root;
            child.parent = parent;
            updateSubContext(child);
        }
    }, appendChildToContainer: function (parent, child) {
        if (child.type === 'native')
            // child.commands.push(['a', { p: parent.refId, c: child.refId }]);
            child.commands.push([2, parent.refId, child.refId]);
    }, insertBefore: function (parent, child, beforeChild) {
        if (!child)
            return;
        if (parent.type === 'native' && parent.subContext)
            parent = parent.subContext;
        if (parent.type === 'native' && child.type === 'native' && beforeChild.type === 'native') {
            // child.commands.push(['i', { p: parent.refId, c: child.refId, i: beforeChild.refId }]);
            child.commands.push([4, parent.refId, child.refId, beforeChild.refId]);
        }
        else if ((parent.type === 'richtext' && child.type === 'richtext' && beforeChild.type === 'richtext') ||
            (parent.type === 'svg' && child.type === 'svg' && beforeChild.type === 'svg')) {
            if ('children' in parent.node) {
                var index = parent.node.children.indexOf(beforeChild.node);
                if (index >= 0)
                    parent.node.children.splice(index, 0, child.node);
                else
                    parent.node.children.push(child.node);
            }
            child.root = parent.root;
            child.parent = parent;
            updateSubContext(child);
        }
    }, insertInContainerBefore: function (parent, child, beforeChild) {
        if (child.type === 'native' && beforeChild.type === 'native')
            // child.commands.push(['i', { p: parent.refId, c: child.refId, i: beforeChild.refId }]);
            child.commands.push([4, parent.refId, child.refId, beforeChild.refId]);
    }, removeChild: function (parent, child) {
        if (!child)
            return;
        if (parent.type === 'native' && parent.subContext)
            parent = parent.subContext;
        if (parent.type === 'native' && child.type === 'native') {
            // child.commands.push(['r', { p: parent.refId, c: child.refId }]);
            child.commands.push([3, parent.refId, child.refId]);
        }
        else if ((parent.type === 'richtext' && child.type === 'richtext') ||
            (parent.type === 'svg' && child.type === 'svg')) {
            if ('children' in parent.node) {
                var index = parent.node.children.indexOf(child.node);
                if (index >= 0)
                    parent.node.children.splice(index, 1);
            }
            updateSubContext(parent);
        }
    }, removeChildFromContainer: function (parent, child) {
        if (child.type === 'native')
            // child.commands.push(['r', { p: parent.refId, c: child.refId }]);
            child.commands.push([3, parent.refId, child.refId]);
    }, resetTextContent: function () { }, preparePortalMount: function () { }, detachDeletedInstance: function () { }, 
    // Required for Suspense
    hideInstance: function (instance) {
        if (instance.type === 'native') {
            // instance.commands.push(['h', { r: instance.refId, h: true }]);
            instance.commands.push([7, instance.refId, true]);
        }
        else if (instance.type === 'richtext' || instance.type === 'svg') {
            instance.node.hidden = true;
            updateSubContext(instance);
        }
    }, hideTextInstance: function (instance) {
        if (instance.type === 'native') {
            // instance.commands.push(['h', { r: instance.refId, h: true }]);
            instance.commands.push([7, instance.refId, true]);
        }
        else if (instance.type === 'richtext' || instance.type === 'svg') {
            instance.node.hidden = true;
            updateSubContext(instance);
        }
    }, unhideInstance: function (instance) {
        if (instance.type === 'native') {
            // instance.commands.push(['h', { r: instance.refId, h: false }]);
            instance.commands.push([7, instance.refId, false]);
        }
        else if (instance.type === 'richtext' || instance.type === 'svg') {
            instance.node.hidden = false;
            updateSubContext(instance);
        }
    }, unhideTextInstance: function (instance) {
        if (instance.type === 'native') {
            // instance.commands.push(['h', { r: instance.refId, h: false }]);
            instance.commands.push([7, instance.refId, false]);
        }
        else if (instance.type === 'richtext' || instance.type === 'svg') {
            instance.node.hidden = false;
            updateSubContext(instance);
        }
    } });
export var asyncReconciler = Reconciler(hostConfig);
